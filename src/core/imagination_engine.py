#!/usr/bin/env python3
"""
Imagination Engine for Simulation Intelligence

This module implements the "imagination" capability that allows the system to
play games it has never seen before by using learned patterns and analogies
from similar games and contexts.
"""

import time
import logging
import numpy as np
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from collections import defaultdict
import math

logger = logging.getLogger(__name__)

@dataclass
class GamePattern:
    """A pattern learned from a specific game type."""
    game_type: str
    pattern_id: str
    action_sequence: List[Tuple[int, Optional[Tuple[int, int]]]]
    success_rate: float
    context_conditions: Dict[str, Any]
    energy_efficiency: float
    learning_efficiency: float
    usage_count: int = 0
    last_used: float = field(default_factory=time.time)
    created_at: float = field(default_factory=time.time)

@dataclass
class AnalogyMapping:
    """Mapping between different game contexts."""
    source_context: str
    target_context: str
    mapping_rules: Dict[str, str]
    confidence: float
    success_rate: float
    usage_count: int = 0
    last_used: float = field(default_factory=time.time)

@dataclass
class ImaginationScenario:
    """A scenario generated by the imagination engine."""
    scenario_id: str
    description: str
    action_sequence: List[Tuple[int, Optional[Tuple[int, int]]]]
    success_probability: float
    confidence: float
    source_patterns: List[str]
    analogy_mappings: List[str]
    energy_cost: float
    learning_potential: float
    created_at: float = field(default_factory=time.time)

class ImaginationEngine:
    """
    Imagination engine that enables playing unseen games through pattern learning
    and analogical reasoning.
    
    This is the core of the "imagination" capability that allows the system to
    generate plausible action sequences for games it has never encountered before.
    """
    
    def __init__(self, 
                 pattern_similarity_threshold: float = 0.6,
                 analogy_confidence_threshold: float = 0.5,
                 max_scenarios: int = 20):
        self.pattern_similarity_threshold = pattern_similarity_threshold
        self.analogy_confidence_threshold = analogy_confidence_threshold
        self.max_scenarios = max_scenarios
        
        # Pattern database
        self.game_patterns: Dict[str, List[GamePattern]] = defaultdict(list)
        self.pattern_index: Dict[str, GamePattern] = {}
        
        # Analogy mappings
        self.analogy_mappings: List[AnalogyMapping] = []
        self.context_mappings: Dict[str, List[AnalogyMapping]] = defaultdict(list)
        
        # Imagination statistics
        self.imagination_stats = {
            'total_scenarios_generated': 0,
            'successful_scenarios': 0,
            'pattern_matches': 0,
            'analogy_matches': 0,
            'novel_scenarios': 0,
            'average_confidence': 0.0
        }
        
        # Learning parameters
        self.learning_rate = 0.1
        self.pattern_decay_rate = 0.95
        self.analogy_decay_rate = 0.98
        
        logger.info("ImaginationEngine initialized")
    
    def imagine_unseen_game(self, 
                           new_game_context: Dict[str, Any],
                           available_actions: List[int],
                           max_scenarios: Optional[int] = None) -> List[ImaginationScenario]:
        """
        Generate imagination scenarios for a game the system has never seen before.
        
        Args:
            new_game_context: Context of the new game
            available_actions: Available actions in the new game
            max_scenarios: Maximum number of scenarios to generate
            
        Returns:
            List of imagination scenarios with action sequences
        """
        
        if max_scenarios is None:
            max_scenarios = self.max_scenarios
        
        scenarios = []
        
        # Find similar patterns from known games
        similar_patterns = self._find_similar_patterns(new_game_context)
        
        # Find analogy mappings
        analogy_mappings = self._find_analogy_mappings(new_game_context)
        
        # Generate scenarios from patterns
        pattern_scenarios = self._generate_scenarios_from_patterns(
            similar_patterns, new_game_context, available_actions
        )
        scenarios.extend(pattern_scenarios)
        
        # Generate scenarios from analogies
        analogy_scenarios = self._generate_scenarios_from_analogies(
            analogy_mappings, new_game_context, available_actions
        )
        scenarios.extend(analogy_scenarios)
        
        # Generate novel scenarios through creative combination
        novel_scenarios = self._generate_novel_scenarios(
            new_game_context, available_actions, similar_patterns
        )
        scenarios.extend(novel_scenarios)
        
        # Score and rank scenarios
        scored_scenarios = self._score_scenarios(scenarios, new_game_context)
        
        # Sort by success probability and confidence
        scored_scenarios.sort(key=lambda s: (s.success_probability, s.confidence), reverse=True)
        
        # Limit to max_scenarios
        final_scenarios = scored_scenarios[:max_scenarios]
        
        # Update statistics
        self.imagination_stats['total_scenarios_generated'] += len(final_scenarios)
        if final_scenarios:
            self.imagination_stats['average_confidence'] = np.mean([s.confidence for s in final_scenarios])
        
        logger.debug(f"Generated {len(final_scenarios)} imagination scenarios for unseen game")
        return final_scenarios
    
    def _find_similar_patterns(self, context: Dict[str, Any]) -> List[GamePattern]:
        """Find patterns similar to the given context."""
        
        similar_patterns = []
        
        for game_type, patterns in self.game_patterns.items():
            for pattern in patterns:
                similarity = self._calculate_pattern_similarity(context, pattern)
                if similarity > self.pattern_similarity_threshold:
                    similar_patterns.append(pattern)
        
        # Sort by similarity
        similar_patterns.sort(key=lambda p: self._calculate_pattern_similarity(context, p), reverse=True)
        
        return similar_patterns[:10]  # Top 10 most similar patterns
    
    def _calculate_pattern_similarity(self, context: Dict[str, Any], pattern: GamePattern) -> float:
        """Calculate similarity between a context and a pattern."""
        
        similarity = 0.0
        
        # Compare context conditions
        for key, value in pattern.context_conditions.items():
            if key in context:
                context_value = context[key]
                if isinstance(value, (int, float)) and isinstance(context_value, (int, float)):
                    # Numeric comparison
                    max_val = max(abs(value), abs(context_value), 1.0)
                    val_sim = 1.0 - abs(value - context_value) / max_val
                    similarity += val_sim * 0.3
                elif isinstance(value, str) and isinstance(context_value, str):
                    # String comparison
                    if value == context_value:
                        similarity += 0.3
                    elif value.lower() in context_value.lower() or context_value.lower() in value.lower():
                        similarity += 0.2
                else:
                    # Generic comparison
                    if value == context_value:
                        similarity += 0.3
        
        # Compare energy levels
        context_energy = context.get('energy', 100.0)
        pattern_energy = pattern.context_conditions.get('energy', 100.0)
        energy_sim = 1.0 - abs(context_energy - pattern_energy) / 100.0
        similarity += energy_sim * 0.2
        
        # Compare learning drive
        context_drive = context.get('learning_drive', 0.5)
        pattern_drive = pattern.context_conditions.get('learning_drive', 0.5)
        drive_sim = 1.0 - abs(context_drive - pattern_drive)
        similarity += drive_sim * 0.2
        
        # Compare action counts
        context_actions = context.get('action_count', 0)
        pattern_actions = pattern.context_conditions.get('action_count', 0)
        action_sim = 1.0 - abs(context_actions - pattern_actions) / 100.0
        similarity += action_sim * 0.1
        
        return min(1.0, similarity)
    
    def _find_analogy_mappings(self, context: Dict[str, Any]) -> List[AnalogyMapping]:
        """Find analogy mappings applicable to the given context."""
        
        applicable_mappings = []
        
        for mapping in self.analogy_mappings:
            if self._is_mapping_applicable(context, mapping):
                applicable_mappings.append(mapping)
        
        # Sort by confidence and success rate
        applicable_mappings.sort(
            key=lambda m: (m.confidence, m.success_rate),
            reverse=True
        )
        
        return applicable_mappings[:5]  # Top 5 most applicable mappings
    
    def _is_mapping_applicable(self, context: Dict[str, Any], mapping: AnalogyMapping) -> bool:
        """Check if an analogy mapping is applicable to the given context."""
        
        # Check if context matches target context
        target_context = mapping.target_context
        context_key = self._create_context_key(context)
        
        # Simple context matching (would be enhanced with more sophisticated matching)
        if target_context in context_key or context_key in target_context:
            return True
        
        # Check mapping rules
        for source_key, target_key in mapping.mapping_rules.items():
            if source_key in context and target_key in context:
                return True
        
        return False
    
    def _create_context_key(self, context: Dict[str, Any]) -> str:
        """Create a key for context identification."""
        
        key_parts = []
        
        # Add game type
        game_type = context.get('game_type', 'unknown')
        key_parts.append(game_type)
        
        # Add energy level bucket
        energy = context.get('energy', 100.0)
        energy_bucket = int(energy // 20) * 20
        key_parts.append(f"energy_{energy_bucket}")
        
        # Add learning drive bucket
        learning_drive = context.get('learning_drive', 0.5)
        drive_bucket = round(learning_drive, 1)
        key_parts.append(f"drive_{drive_bucket}")
        
        return "_".join(key_parts)
    
    def _generate_scenarios_from_patterns(self, 
                                        patterns: List[GamePattern],
                                        context: Dict[str, Any],
                                        available_actions: List[int]) -> List[ImaginationScenario]:
        """Generate scenarios by adapting patterns to the new context."""
        
        scenarios = []
        
        for pattern in patterns:
            # Adapt pattern to new context
            adapted_sequence = self._adapt_pattern_to_context(pattern, context, available_actions)
            
            if not adapted_sequence:
                continue
            
            # Calculate success probability
            success_prob = self._calculate_scenario_success_probability(
                adapted_sequence, context, pattern
            )
            
            # Calculate confidence
            confidence = self._calculate_scenario_confidence(pattern, context)
            
            # Calculate costs
            energy_cost = self._calculate_energy_cost(adapted_sequence)
            learning_potential = self._calculate_learning_potential(adapted_sequence, context)
            
            # Create scenario
            scenario = ImaginationScenario(
                scenario_id=f"pattern_{pattern.pattern_id}_{int(time.time())}",
                description=f"Adapted from {pattern.game_type} pattern",
                action_sequence=adapted_sequence,
                success_probability=success_prob,
                confidence=confidence,
                source_patterns=[pattern.pattern_id],
                analogy_mappings=[],
                energy_cost=energy_cost,
                learning_potential=learning_potential
            )
            
            scenarios.append(scenario)
            self.imagination_stats['pattern_matches'] += 1
        
        return scenarios
    
    def _adapt_pattern_to_context(self, 
                                 pattern: GamePattern,
                                 context: Dict[str, Any],
                                 available_actions: List[int]) -> List[Tuple[int, Optional[Tuple[int, int]]]]:
        """Adapt a pattern to work in the new context."""
        
        adapted_sequence = []
        
        for action, coords in pattern.action_sequence:
            # Check if action is available
            if action not in available_actions:
                # Try to find a similar action
                similar_action = self._find_similar_action(action, available_actions)
                if similar_action is None:
                    continue
                action = similar_action
            
            # Adapt coordinates if needed
            adapted_coords = coords
            if action == 6 and coords:  # Coordinate action
                adapted_coords = self._adapt_coordinates(coords, context)
            
            adapted_sequence.append((action, adapted_coords))
        
        return adapted_sequence
    
    def _find_similar_action(self, original_action: int, available_actions: List[int]) -> Optional[int]:
        """Find a similar action from the available actions."""
        
        # Action similarity mapping
        action_groups = {
            'movement': [1, 2, 3, 4],
            'interaction': [5],
            'coordinate': [6],
            'undo': [7]
        }
        
        # Find group for original action
        original_group = None
        for group, actions in action_groups.items():
            if original_action in actions:
                original_group = group
                break
        
        if original_group is None:
            return None
        
        # Find similar action in available actions
        for action in available_actions:
            if action in action_groups[original_group]:
                return action
        
        # If no similar action found, return first available action
        return available_actions[0] if available_actions else None
    
    def _adapt_coordinates(self, 
                          original_coords: Tuple[int, int],
                          context: Dict[str, Any]) -> Tuple[int, int]:
        """Adapt coordinates to the new context."""
        
        x, y = original_coords
        
        # Simple adaptation: scale coordinates based on context
        # This would be enhanced with more sophisticated coordinate mapping
        
        # Get context dimensions if available
        grid_width = context.get('grid_width', 64)
        grid_height = context.get('grid_height', 64)
        
        # Scale coordinates to fit new grid
        if grid_width != 64 or grid_height != 64:
            scale_x = grid_width / 64.0
            scale_y = grid_height / 64.0
            x = int(x * scale_x)
            y = int(y * scale_y)
        
        # Ensure coordinates are within bounds
        x = max(0, min(grid_width - 1, x))
        y = max(0, min(grid_height - 1, y))
        
        return (x, y)
    
    def _generate_scenarios_from_analogies(self, 
                                         mappings: List[AnalogyMapping],
                                         context: Dict[str, Any],
                                         available_actions: List[int]) -> List[ImaginationScenario]:
        """Generate scenarios using analogy mappings."""
        
        scenarios = []
        
        for mapping in mappings:
            # Find patterns from source context
            source_patterns = self._find_patterns_by_context(mapping.source_context)
            
            for pattern in source_patterns:
                # Apply analogy mapping
                mapped_sequence = self._apply_analogy_mapping(pattern, mapping, context, available_actions)
                
                if not mapped_sequence:
                    continue
                
                # Calculate success probability
                success_prob = self._calculate_scenario_success_probability(
                    mapped_sequence, context, pattern
                ) * mapping.confidence
                
                # Calculate confidence
                confidence = self._calculate_scenario_confidence(pattern, context) * mapping.confidence
                
                # Calculate costs
                energy_cost = self._calculate_energy_cost(mapped_sequence)
                learning_potential = self._calculate_learning_potential(mapped_sequence, context)
                
                # Create scenario
                scenario = ImaginationScenario(
                    scenario_id=f"analogy_{mapping.source_context}_{int(time.time())}",
                    description=f"Analogy from {mapping.source_context} to {mapping.target_context}",
                    action_sequence=mapped_sequence,
                    success_probability=success_prob,
                    confidence=confidence,
                    source_patterns=[pattern.pattern_id],
                    analogy_mappings=[f"{mapping.source_context}_{mapping.target_context}"],
                    energy_cost=energy_cost,
                    learning_potential=learning_potential
                )
                
                scenarios.append(scenario)
                self.imagination_stats['analogy_matches'] += 1
        
        return scenarios
    
    def _find_patterns_by_context(self, context_key: str) -> List[GamePattern]:
        """Find patterns by context key."""
        
        patterns = []
        for game_type, pattern_list in self.game_patterns.items():
            for pattern in pattern_list:
                pattern_context_key = self._create_context_key(pattern.context_conditions)
                if context_key in pattern_context_key or pattern_context_key in context_key:
                    patterns.append(pattern)
        
        return patterns
    
    def _apply_analogy_mapping(self, 
                              pattern: GamePattern,
                              mapping: AnalogyMapping,
                              context: Dict[str, Any],
                              available_actions: List[int]) -> List[Tuple[int, Optional[Tuple[int, int]]]]:
        """Apply analogy mapping to a pattern."""
        
        mapped_sequence = []
        
        for action, coords in pattern.action_sequence:
            # Apply action mapping if available
            mapped_action = action
            if str(action) in mapping.mapping_rules:
                mapped_action = int(mapping.mapping_rules[str(action)])
            
            # Check if mapped action is available
            if mapped_action not in available_actions:
                similar_action = self._find_similar_action(mapped_action, available_actions)
                if similar_action is None:
                    continue
                mapped_action = similar_action
            
            # Apply coordinate mapping if available
            mapped_coords = coords
            if coords and 'coordinate_mapping' in mapping.mapping_rules:
                # Apply coordinate transformation
                mapping_rule = mapping.mapping_rules['coordinate_mapping']
                mapped_coords = self._apply_coordinate_mapping(coords, mapping_rule, context)
            
            mapped_sequence.append((mapped_action, mapped_coords))
        
        return mapped_sequence
    
    def _apply_coordinate_mapping(self, 
                                 coords: Tuple[int, int],
                                 mapping_rule: str,
                                 context: Dict[str, Any]) -> Tuple[int, int]:
        """Apply coordinate mapping rule."""
        
        x, y = coords
        
        # Simple mapping rules (would be enhanced with more sophisticated rules)
        if mapping_rule == "mirror_x":
            x = 63 - x
        elif mapping_rule == "mirror_y":
            y = 63 - y
        elif mapping_rule == "rotate_90":
            x, y = y, 63 - x
        elif mapping_rule == "scale_2x":
            x = min(63, x * 2)
            y = min(63, y * 2)
        elif mapping_rule == "scale_0.5x":
            x = x // 2
            y = y // 2
        
        return (x, y)
    
    def _generate_novel_scenarios(self, 
                                 context: Dict[str, Any],
                                 available_actions: List[int],
                                 similar_patterns: List[GamePattern]) -> List[ImaginationScenario]:
        """Generate novel scenarios through creative combination."""
        
        scenarios = []
        
        # Combine patterns creatively
        if len(similar_patterns) >= 2:
            combined_scenario = self._combine_patterns(similar_patterns, context, available_actions)
            if combined_scenario:
                scenarios.append(combined_scenario)
        
        # Generate random exploration scenarios
        random_scenarios = self._generate_random_scenarios(context, available_actions, 3)
        scenarios.extend(random_scenarios)
        
        # Generate energy-efficient scenarios
        efficient_scenarios = self._generate_efficient_scenarios(context, available_actions, 2)
        scenarios.extend(efficient_scenarios)
        
        self.imagination_stats['novel_scenarios'] += len(scenarios)
        return scenarios
    
    def _combine_patterns(self, 
                         patterns: List[GamePattern],
                         context: Dict[str, Any],
                         available_actions: List[int]) -> Optional[ImaginationScenario]:
        """Combine multiple patterns into a novel scenario."""
        
        if len(patterns) < 2:
            return None
        
        # Take first half from first pattern, second half from second pattern
        pattern1, pattern2 = patterns[0], patterns[1]
        
        combined_sequence = []
        
        # First half from pattern1
        half_length = len(pattern1.action_sequence) // 2
        for action, coords in pattern1.action_sequence[:half_length]:
            if action in available_actions:
                combined_sequence.append((action, coords))
        
        # Second half from pattern2
        for action, coords in pattern2.action_sequence[half_length:]:
            if action in available_actions:
                combined_sequence.append((action, coords))
        
        if not combined_sequence:
            return None
        
        # Calculate metrics
        success_prob = (pattern1.success_rate + pattern2.success_rate) / 2.0
        confidence = 0.6  # Lower confidence for novel combinations
        energy_cost = self._calculate_energy_cost(combined_sequence)
        learning_potential = self._calculate_learning_potential(combined_sequence, context)
        
        return ImaginationScenario(
            scenario_id=f"novel_combination_{int(time.time())}",
            description=f"Combination of {pattern1.game_type} and {pattern2.game_type} patterns",
            action_sequence=combined_sequence,
            success_probability=success_prob,
            confidence=confidence,
            source_patterns=[pattern1.pattern_id, pattern2.pattern_id],
            analogy_mappings=[],
            energy_cost=energy_cost,
            learning_potential=learning_potential
        )
    
    def _generate_random_scenarios(self, 
                                  context: Dict[str, Any],
                                  available_actions: List[int],
                                  count: int) -> List[ImaginationScenario]:
        """Generate random exploration scenarios."""
        
        scenarios = []
        
        for i in range(count):
            # Generate random sequence
            sequence_length = np.random.randint(3, 8)
            sequence = []
            
            for _ in range(sequence_length):
                action = np.random.choice(available_actions)
                coords = None
                
                if action == 6:  # Coordinate action
                    coords = (np.random.randint(0, 64), np.random.randint(0, 64))
                
                sequence.append((action, coords))
            
            # Calculate metrics
            success_prob = 0.3  # Low probability for random sequences
            confidence = 0.2
            energy_cost = self._calculate_energy_cost(sequence)
            learning_potential = self._calculate_learning_potential(sequence, context)
            
            scenario = ImaginationScenario(
                scenario_id=f"random_{i}_{int(time.time())}",
                description="Random exploration scenario",
                action_sequence=sequence,
                success_probability=success_prob,
                confidence=confidence,
                source_patterns=[],
                analogy_mappings=[],
                energy_cost=energy_cost,
                learning_potential=learning_potential
            )
            
            scenarios.append(scenario)
        
        return scenarios
    
    def _generate_efficient_scenarios(self, 
                                     context: Dict[str, Any],
                                     available_actions: List[int],
                                     count: int) -> List[ImaginationScenario]:
        """Generate energy-efficient scenarios."""
        
        scenarios = []
        
        for i in range(count):
            # Generate efficient sequence (prefer low-energy actions)
            sequence = []
            energy_budget = context.get('energy', 100.0) * 0.3  # Use 30% of energy
            
            while energy_budget > 0 and len(sequence) < 10:
                # Prefer low-energy actions
                low_energy_actions = [a for a in available_actions if a in [1, 2, 3, 4, 7]]
                if low_energy_actions:
                    action = np.random.choice(low_energy_actions)
                else:
                    action = np.random.choice(available_actions)
                
                coords = None
                if action == 6:
                    coords = (np.random.randint(0, 64), np.random.randint(0, 64))
                
                # Calculate energy cost
                energy_cost = self._calculate_action_energy_cost(action, coords)
                if energy_cost <= energy_budget:
                    sequence.append((action, coords))
                    energy_budget -= energy_cost
                else:
                    break
            
            if not sequence:
                continue
            
            # Calculate metrics
            success_prob = 0.4  # Medium probability for efficient sequences
            confidence = 0.5
            energy_cost = self._calculate_energy_cost(sequence)
            learning_potential = self._calculate_learning_potential(sequence, context)
            
            scenario = ImaginationScenario(
                scenario_id=f"efficient_{i}_{int(time.time())}",
                description="Energy-efficient scenario",
                action_sequence=sequence,
                success_probability=success_prob,
                confidence=confidence,
                source_patterns=[],
                analogy_mappings=[],
                energy_cost=energy_cost,
                learning_potential=learning_potential
            )
            
            scenarios.append(scenario)
        
        return scenarios
    
    def _score_scenarios(self, 
                        scenarios: List[ImaginationScenario],
                        context: Dict[str, Any]) -> List[ImaginationScenario]:
        """Score and rank scenarios."""
        
        for scenario in scenarios:
            # Adjust success probability based on context
            context_adjustment = self._calculate_context_adjustment(scenario, context)
            scenario.success_probability *= context_adjustment
            
            # Adjust confidence based on source patterns
            pattern_confidence = self._calculate_pattern_confidence(scenario)
            scenario.confidence = (scenario.confidence + pattern_confidence) / 2.0
        
        return scenarios
    
    def _calculate_scenario_success_probability(self, 
                                              sequence: List[Tuple[int, Optional[Tuple[int, int]]]],
                                              context: Dict[str, Any],
                                              pattern: Optional[GamePattern] = None) -> float:
        """Calculate success probability for a scenario."""
        
        if pattern:
            base_prob = pattern.success_rate
        else:
            base_prob = 0.5
        
        # Adjust based on sequence length
        length_adjustment = 1.0 - (len(sequence) - 5) * 0.05  # Penalty for very long sequences
        
        # Adjust based on energy level
        energy = context.get('energy', 100.0)
        energy_adjustment = energy / 100.0
        
        # Adjust based on learning drive
        learning_drive = context.get('learning_drive', 0.5)
        drive_adjustment = 0.5 + learning_drive * 0.5
        
        final_prob = base_prob * length_adjustment * energy_adjustment * drive_adjustment
        return max(0.0, min(1.0, final_prob))
    
    def _calculate_scenario_confidence(self, 
                                     pattern: GamePattern,
                                     context: Dict[str, Any]) -> float:
        """Calculate confidence for a scenario."""
        
        # Base confidence from pattern
        base_confidence = pattern.success_rate
        
        # Adjust based on pattern usage
        usage_adjustment = min(1.0, pattern.usage_count / 10.0)
        
        # Adjust based on context similarity
        context_similarity = self._calculate_pattern_similarity(context, pattern)
        
        final_confidence = base_confidence * usage_adjustment * context_similarity
        return max(0.1, min(1.0, final_confidence))
    
    def _calculate_energy_cost(self, sequence: List[Tuple[int, Optional[Tuple[int, int]]]]) -> float:
        """Calculate total energy cost of a sequence."""
        
        total_cost = 0.0
        for action, coords in sequence:
            total_cost += self._calculate_action_energy_cost(action, coords)
        
        return total_cost
    
    def _calculate_action_energy_cost(self, action: int, coords: Optional[Tuple[int, int]]) -> float:
        """Calculate energy cost of a single action."""
        
        base_costs = {
            1: 0.5,  # Movement actions
            2: 0.5,
            3: 0.5,
            4: 0.5,
            5: 1.0,  # Interaction actions
            6: 2.0,  # Coordinate actions
            7: 0.1   # Undo actions
        }
        
        cost = base_costs.get(action, 1.0)
        
        # Additional cost for coordinate actions based on distance from center
        if action == 6 and coords:
            x, y = coords
            center_distance = abs(x - 32) + abs(y - 32)
            cost += center_distance / 100.0
        
        return cost
    
    def _calculate_learning_potential(self, 
                                     sequence: List[Tuple[int, Optional[Tuple[int, int]]]],
                                     context: Dict[str, Any]) -> float:
        """Calculate learning potential of a sequence."""
        
        potential = 0.0
        
        # Base potential from sequence length
        potential += len(sequence) * 0.1
        
        # Bonus for coordinate actions
        coord_actions = sum(1 for action, _ in sequence if action == 6)
        potential += coord_actions * 0.2
        
        # Bonus for action diversity
        unique_actions = len(set(action for action, _ in sequence))
        potential += unique_actions * 0.05
        
        # Adjust based on context
        learning_drive = context.get('learning_drive', 0.5)
        potential *= learning_drive
        
        return min(1.0, potential)
    
    def _calculate_context_adjustment(self, 
                                     scenario: ImaginationScenario,
                                     context: Dict[str, Any]) -> float:
        """Calculate context adjustment for a scenario."""
        
        adjustment = 1.0
        
        # Adjust based on energy level
        energy = context.get('energy', 100.0)
        if energy < 30 and scenario.energy_cost > energy * 0.5:
            adjustment *= 0.5  # Penalty for high-energy scenarios when energy is low
        
        # Adjust based on learning drive
        learning_drive = context.get('learning_drive', 0.5)
        if learning_drive > 0.7 and scenario.learning_potential > 0.5:
            adjustment *= 1.2  # Bonus for high-learning scenarios when drive is high
        
        return adjustment
    
    def _calculate_pattern_confidence(self, scenario: ImaginationScenario) -> float:
        """Calculate confidence based on source patterns."""
        
        if not scenario.source_patterns:
            return 0.3  # Low confidence for scenarios without source patterns
        
        # Find patterns and calculate average confidence
        pattern_confidences = []
        for pattern_id in scenario.source_patterns:
            if pattern_id in self.pattern_index:
                pattern = self.pattern_index[pattern_id]
                pattern_confidences.append(pattern.success_rate)
        
        if pattern_confidences:
            return np.mean(pattern_confidences)
        else:
            return 0.3
    
    def learn_from_outcome(self, 
                          scenario: ImaginationScenario,
                          actual_success: bool,
                          context: Dict[str, Any]):
        """Learn from the outcome of an imagination scenario."""
        
        # Update pattern success rates
        for pattern_id in scenario.source_patterns:
            if pattern_id in self.pattern_index:
                pattern = self.pattern_index[pattern_id]
                if actual_success:
                    pattern.success_rate = min(1.0, pattern.success_rate + self.learning_rate)
                else:
                    pattern.success_rate = max(0.0, pattern.success_rate - self.learning_rate)
                pattern.usage_count += 1
                pattern.last_used = time.time()
        
        # Update analogy mappings
        for mapping_key in scenario.analogy_mappings:
            for mapping in self.analogy_mappings:
                if f"{mapping.source_context}_{mapping.target_context}" == mapping_key:
                    if actual_success:
                        mapping.success_rate = min(1.0, mapping.success_rate + self.learning_rate)
                    else:
                        mapping.success_rate = max(0.0, mapping.success_rate - self.learning_rate)
                    mapping.usage_count += 1
                    mapping.last_used = time.time()
        
        # Update statistics
        if actual_success:
            self.imagination_stats['successful_scenarios'] += 1
        
        logger.debug(f"Learned from imagination scenario outcome: success={actual_success}")
    
    def add_pattern(self, pattern: GamePattern):
        """Add a new pattern to the database."""
        
        self.game_patterns[pattern.game_type].append(pattern)
        self.pattern_index[pattern.pattern_id] = pattern
        
        logger.debug(f"Added pattern {pattern.pattern_id} for game type {pattern.game_type}")
    
    def add_analogy_mapping(self, mapping: AnalogyMapping):
        """Add a new analogy mapping."""
        
        self.analogy_mappings.append(mapping)
        self.context_mappings[mapping.source_context].append(mapping)
        
        logger.debug(f"Added analogy mapping from {mapping.source_context} to {mapping.target_context}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get comprehensive statistics about the imagination engine."""
        
        return {
            'imagination_stats': self.imagination_stats,
            'pattern_database': {
                'total_patterns': sum(len(patterns) for patterns in self.game_patterns.values()),
                'game_types': len(self.game_patterns),
                'patterns_by_type': {
                    game_type: len(patterns) 
                    for game_type, patterns in self.game_patterns.items()
                }
            },
            'analogy_mappings': {
                'total_mappings': len(self.analogy_mappings),
                'contexts_mapped': len(self.context_mappings)
            }
        }
